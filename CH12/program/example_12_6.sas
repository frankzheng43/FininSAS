data a;
   do t=1 to 500;
      x=rannor(1);
      if x=<-0.5 then y=1-2*x+rannor(2);
      else if -0.5<x=<0.5 then y=2+10*x+rannor(2);
      else y=	1-6*x+rannor(2); /*produce 3 different pieces data*/
      drop t;
      output;
   end;
run;
proc sort;by x;
run;
data a;
   set a;
      t=_n_;
run;
data a;
   set a;
      do i=10 to 490;
         output;
      end;
run;
data a;
   set a;
      if i>=t then d1=1;else d1=0;
      if d1=1 then d2=0;else d2=1;
run;
proc sort data=a;by i d1;
run;
proc reg data=a noprint outest=k(keep=_p_ i d1 _rsq_) adjrsq;
   model y=x;
   by i d1;
   output out=a r=r2;
quit;
proc reg data=a  noprint;
   model y=x;
   output out=a r=r1;
   by i;
quit;
proc sort data=k;by descending d1 descending _rsq_;
run;
data k;
   set k;
      if _n_=1 then output;
run;
data a;
   merge k a;by i;
      if _p_=. then delete;
run;
data b;
   set a;
      knot=x;
      if i=t then output;
      keep knot i;
run;
data a;
   merge a b;by i;
      du1=x*d1;
      du2=(x-knot)*d2;
run;
proc sort data=a;by i;
run;
proc reg data=a noprint outest=b adjrsq;
   model y=du1-du2;
   by i ;
quit;
data a;
   set a;
      ESS1=r1**2;
      ESS2=r2**2;
run;
proc means data=a noprint;
   var ess1 ess2 knot;
   by i;
   output out=aa sum=ESS1 ESS2 knot n=n;
run;
proc means data=k noprint;
   var _p_;
   by i;
   output out=k mean=_p_ n=k;
run;
data aa;
   merge aa k;by i;
      knot=knot/n;
      Chow=(((ESS1-ESS2)/_p_)/(ESS2/(N-k*_p_)));
      ProbF=1-probf(Chow,_p_,N-2*_p_);
      keep i Chow ProbF knot;
run;
proc means noprint data=b;
   var _adjrsq_;
   by _DEPVAR_;
   output out=c(drop=_type_ _freq_ ) max=r;
run;
data b;
   merge  b c;by _DEPVAR_;
      if _adjrsq_=r then output;
      keep i intercept du1-du100;
run;
data beta;
   set b;
      beta1=du1;
      keep i beta1;
run;
data chow;
   set aa;
run;
proc reg data=a;
   model y=du1 du2;
      test du1;
      test du2;
      test du1 ,du2;
quit;

/*the macro for second and more piece*/
%macro piecewise(du1,du2,nobs);
   data a;
      merge  a beta;by i;
         start=i;
         keep y  x y t start  du1-du100 ;
   run;

   data a;
      set a;
         do i=start+5 to &nobs-10;
            output;
         end;
   run;
   data a;
      set a;
         if i>=t then d1=1;else d1=0;
         if d1=1 then d2=0;else d2=1;
   run;
   proc sort data=a;by i d1;
   run;
   proc reg data=a noprint outest=k(keep=_p_ i d1 _rsq_) adjrsq;
      model y=du1- &du1;
      by i d1;
      output out=a r=r2;
   quit;
   proc reg data=a  noprint;
      model y=du1-&du1;
      output out=a r=r1;
      by i;
   quit;

   proc sort data=k;by descending d1 descending _rsq_;
   run;
   data k;
      set k;
         if _n_=1 then output;
   run;
   data a;
      merge k a;by i;
         if _p_=. then delete;
   run;
   data b;
      set a;
         knot=x;
         if i=t then output;
         keep knot i;
   run;
   proc sort data=a;by i;
   run;
   data a;
      merge a b;by i;
         &du1=&du1*d1;
         &du2=(x-knot)*d2;
   run;
   proc sort data=a;by i;
   run;
   proc reg data=a noprint outest=b adjrsq;
      model y=du1-&du2	;
      by i ;
   quit;
   data a;
      set a;
         ESS1=r1**2;
         ESS2=r2**2;
   run;
   proc means data=a noprint;
      var ess1 ess2 knot;
      by i;
      output out=aa sum=ESS1 ESS2 knot n=n;
   run;
   proc means data=k noprint;
      var _p_;
      by i;
      output out=k mean=_p_ n=k;
   run;
   data aa;
      merge aa k;by i;
         knot=knot/n;
         Chow=(((ESS1-ESS2)/_p_)/(ESS2/(N-k*_p_)));
         ProbF=1-probf(Chow,_p_,N-2*_p_);
         keep i Chow ProbF knot;
   run;
   proc means noprint data=b;
      var _adjrsq_;
      by _DEPVAR_;
      output out=c(drop=_type_ _freq_ ) max=r;
   run;
   data b;
      merge  b c;by _DEPVAR_;
         if _adjrsq_=r then output;
         keep i intercept du1-du100;
   run;
   data beta;
      set  b;
         keep i ;
   run;
   data chow;
      set chow aa;
   run;
   proc reg data=a;
      model y=du1-&du2;
   quit;
%mend;
%piecewise(du2,du3,500);
%piecewise(du3,du4,500);
